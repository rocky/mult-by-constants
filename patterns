#!/usr/local/bin/perl

use strict;

my $RCSID = '$Id: patterns 1.12 2000/11/29 14:17:45 lefevre Exp lefevre $';
my ($proc) = $RCSID =~ /Id: (\S+)/ or die;

my $Usage = <<EOF;
$proc <mode> <algo> <args...>

Mode a:
  Arg1... odd binary number.
  Arg2... output level (optional).
  Out.... SAS-chain.

Mode b:
  Arg1... number of digits (> 1).
  Out.... comparisons with Bernstein's algorithm.

Mode m:
  Arg1... number of digits (> 1).
  Out.... maximum and average number of operations.

Mode w:
  Arg1... number of digits (> 1).
  Out.... worst cases.

Algo s: simple algorithm (as described in the thesis)
Algo g: global algorithm (common subpatterns)
EOF

@ARGV > 1 or die $Usage;
my $mode = shift;
my $algo = shift;
my @sign = ('+','-');
my $level = 0;
my @sas;

my $subsas;
if ($algo eq 's')
  { $subsas = \&recsas; }
elsif ($algo eq 'g')
  { $subsas = \&gsas; }
else
  { die $Usage; }

if ($mode eq 'a')
  {
    my ($a,$b);
    ($a = shift) =~ /^[01]*1$/ or die $Usage;
    $level = shift;
    $b = &booth($a);
    $level > 1 and print "Booth recoding: $b.\n";
    &$subsas($b);
    $level > 1 and print "\n";
    print "Cost($a) = ", scalar(@sas), "\n";
    $level and print @sas;
  }
elsif ($mode eq 'm' || $mode eq 'b')
  {
    my ($i,$n,%d);

    ($n = $ARGV[0]) =~ /^\d+$/ && $n > 1 or die $Usage;
    my ($pmax,$psum) = (0,0);
    my ($bmax,$bsum) = (0,0);
    if ($mode eq 'b')
      {
        use IPC::Open2;
        open2(\*RD, \*WR, "./bernstein 0");
        # Note: this program must make sure that it does not take too
        # much memory when caching information about the constants!
      }
    for ($i = (1<<($n-1))+1; $i < 1<<$n; $i += 2)
      {
        @sas = ();
        my $a = unpack 'B*', pack 'N', $i;
        $a =~ s/^0*//;
        my $q = &$subsas(&booth($a));
        $psum += $q;
        $q > $pmax and $pmax = $q;
        $mode eq 'm' and next;
        print WR "$i\n";
        <RD> =~ /^Cost\($i\) = (\d+)$/ or die "$proc: error with bernstein";
        $bsum += $1;
        $1 > $bmax and $bmax = $1;
        $q != $1 and $d{$q-$1}++;
      }
    if ($mode eq 'b')
      {
        close WR;
        close RD;
        print "Bernstein:\n";
        print "qmax = $bmax\n";
        print "qav = $bsum / 2^", $n-2, " = ", $bsum/(1<<($n-2)), "\n\n";
        print "Patterns:\n";
      }
    print "qmax = $pmax\n";
    print "qav = $psum / 2^", $n-2, " = ", $psum/(1<<($n-2)), "\n";
    if (%d)
      {
        print "\nDifferences:\n";
        foreach (sort { $a <=> $b } keys %d)
          { printf "%+d: %5d\n", $_, $d{$_} }
      }
  }
elsif ($mode eq 'w')
  {
    my ($i,$n,@w);

    ($n = $ARGV[0]) =~ /^\d+$/ && $n > 1 or die $Usage;
    my $qmax = 0;
    for ($i = (1<<($n-1))+1; $i < 1<<$n; $i += 2)
      {
        @sas = ();
        my $a = unpack 'B*', pack 'N', $i;
        $a =~ s/^0*//;
        my $q = &$subsas(&booth($a));
        $q == $qmax && @w < 32 and push @w, $a;
        $q > $qmax or next;
        $qmax = $q;
        @w = ($a);
      }
    print "qmax = $qmax\n";
    foreach (@w)
      { print "$_\n" }
  }
else
  { die $Usage; }

sub booth
  { my ($a,$b) = ("00$_[0]","");
    while ($a =~ /^(.*?)(0*)0(1*)1$/o)
      { length $3 or ($a,$b) = ($1,$2.'0P'.$b), next;
        my $z = ('0' x length $3).'N'.$b;
        ($a,$b) = length $2 ? ($1,$2.'P'.$z) : ($1.'1',$z); }
    $b =~ s/^0*//;
    return $b; }

sub recsas
  { my $s = $_[0];
    $s =~ s/0*$//;
    my $l = length($s) - 1;
    $l or return 0;
    my ($i,$j,$c,$d,$w,$t,$u,$f,$g,@p,@n,%w);
    for($i=0;$i<=$l;$i++)
      { my $d = substr $s, $l-$i, 1;
        $d eq 'P' and push @p, $i;
        $d eq 'N' and push @n, $i; }
    print "\nrecsas: $s.\n  P: @p\n  N: @n\n" if ($level > 2);
    foreach $i (1..$#p) { foreach $j (0..$i-1) { $w{$p[$i]-$p[$j]}++ } }
    foreach $i (1..$#n) { foreach $j (0..$i-1) { $w{$n[$i]-$n[$j]}++ } }
    foreach $i (0..$#p) { foreach $j (0..$#n) { $w{-abs($p[$i]-$n[$j])}++ } }
    my @d = sort { $w{$a} <=> $w{$b} || $a <=> $b } keys %w;
    if ($level > 3)
      { my $i = $#d;
        do
          { printf "%3d, w = %d\n", $d[$i], $w{$d[$i]} }
        while (--$i >= 0); }
    while ($w{$d = pop @d} > $w)
      { $_ = $s;
        my $x = 0;
        my $z = abs($d) - 1;
        if ($d > 0)
          {
            while (s/P(.{$z})P/0${1}p/) { $x++ }
            while (s/N(.{$z})N/0${1}n/) { $x++ }
          }
        else
          {
            my ($y,@y);
            while (($y) = /(P.{$z}N|N.{$z}P)/)
              { @y = $y =~ /^(.)(.{$z})/ or die;
                s/$y/0$y[1]\L$y[0]\E/;
                $x++; }
          }
        $x > $w and $w = $x, $c = $d, $t = $_; }
    $u = $t;
    $t =~ tr/pn/00/;
    $u =~ tr/pnPN/PN00/;
    $f = $c < 0 and $c = -$c;
    $g = $u =~ /^0*N/ and $u =~ tr/PN/NP/;
    print <<EOF if ($level > 2);
    t = $t
    u = $u
  --> t $sign[$g] (u << $c $sign[$f] u)
EOF
    $u =~ s/^0*//;
    $i = &recsas($u);
    push @sas, "u".(@sas+1)." = u$i << $c $sign[$f] u$i\n";
    $i = @sas;
    $t =~ s/^0*//;
    $t or return $i;
    substr($t,0,1) eq 'P' or $g = 2, $t =~ tr/PN/NP/;
    $j = &recsas($t);
    $u =~ /(0*)$/;
    $u = "u$i";
    length($1) and $u .= ' << '.length($1);
    $t =~ /(0*)$/;
    $t = "u$j";
    length($1) and $t .= ' << '.length($1);
    push @sas, "u".(@sas+1).' = '.("$t + $u","$t - $u","$u - $t")[$g]."\n";
    return scalar @sas; }

sub gsas
  {
    my @x = (&makeind($_[0]));
    my %sign = ('PP' => '+', 'PN' => '-', 'NP' => '-', 'NN' => '+');
    while (@x)
      {
        $level > 2
          and print "\ngsas: ", join('+', map { $$_{'s'} } @x),
                    "\n      ", join(' ', map { &ind($$_{'s'}) } @x),
                    "\n";
        my (%v,%w);
        foreach (0 .. $#x)
          {
            my ($s1,$d1) = @{$x[$_]}{'s','d'};
            my $key1 = $_;
            foreach ($_ .. $#x)
              {
                my ($s2,$d2) = @{$x[$_]}{'s','d'};
                my $same = $_ == $key1;
                my $key2 = "$key1,$_,";
                my $i1;
                foreach $i1 (@$d1)
                  {
                    my $b1 = substr($s1, -($i1+1), 1);
                    my $i2;
                    foreach $i2 (@$d2)
                     {
                       $same && $i1 <= $i2 and next;
                       my $b2 = substr($s2, -($i2+1), 1);
                       my $key = $key2.($i1-$i2).$sign{$b1.$b2};
                       push @{$v{$key}}, $i2;
                       $w{$key}++;
                     }
                  }
              }
          }
        my @d = sort { $w{$a} <=> $w{$b} || $a <=> $b } keys %w;
        if ($level > 3)
          { my $i = $#d;
            do
              {
                my $key = $d[$i];
                my @a = $key =~ /^(\d+),(\d+),(\d+)([-+])$/ or die;
                printf "%3d, %3d, %3d, %s, w = $w{$key} (@{$v{$key}})\n", @a;
              }
            while (--$i >= 0); }
        my ($c,$d);
        my $w = 0;
        while ($w{$d = pop @d} > $w)
          {
            my ($i1,$i2) = $d =~ /^(\d+),(\d+),/ or die;
            $i1 != $i2 and ($c,$w) = ($d,$w{$d}), last;

          }
exit;
      }
  }

sub makeind
  { my $s = $_[0];
    $s =~ s/0*$//;
    my $l = length $s;
    my ($i,@d);
    for ($i = 0; $i < $l; $i++)
      { push @d, $i unless (substr($s, -($i+1), 1) eq '0'); }
    $level > 3 and print "\nmakeind: $s (@d).\n";
    return { 's' => $s, 'd' => \@d }; }

sub ind
  { my $s = $_[0];
    my ($i,$r);
    for ($i = length($s) - 1; $i >= 0; $i--)
      { $r .= $i % 10; }
    return $r; }
